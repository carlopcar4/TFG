'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/* defaults.js
 ========================================================================== */
// Global configuration
var config = {
  documentSelector: '.js-document',
  documentDisabledClass: 'is-disabled',
  openingTriggerActiveClass: 'is-active',
  delay: 200
};

/* focusableElements.js
 ========================================================================== */
// Keyboard focusable elements
var focusableElements = ['[href]:not([tabindex^="-"])', 'input:not([disabled]):not([type="hidden"]):not([tabindex^="-"]):not([type="radio"])', 'input[type="radio"]:checked', 'select:not([disabled]):not([tabindex^="-"])', 'textarea:not([disabled]):not([tabindex^="-"])', 'button:not([disabled]):not([tabindex^="-"])', '[tabindex]:not([tabindex^="-"])', '[contenteditable="true"]:not([tabindex^="-"])'];

/* keyCodes.js
 ========================================================================== */
// Keyboard codes
var keyCodes = {
  escape: 'Escape',
  tab: 'Tab',
  f6: 'F6'
};

/* utils.js
 ========================================================================== */
// Only get visible elements
function getVisibleElements(elements) {
  var visibleElements = [];
  elements.forEach(function (element) {
    var bounding = element.getBoundingClientRect();
    var isVisible = bounding.width > 0 || bounding.height > 0;
    if (isVisible) visibleElements.push(element);
  });
  return visibleElements;
} // Only get no nested elements

function getNoNestedElements(context, selector, elements) {
  var nestedComponents = context.querySelectorAll(selector);
  var noNestedElements = [];
  var isNested = false;
  if (nestedComponents.length === 0) return elements;
  elements.forEach(function (element) {
    nestedComponents.forEach(function (nestedComponent) {
      if (nestedComponent.contains(element)) isNested = true;
    });
    if (!isNested) noNestedElements.push(element);
    isNested = false;
  });
  return noNestedElements;
} // Check if the parent elements match the target

function closest(element, target) {
  var currentElement = element;

  while (currentElement !== target && currentElement) {
    currentElement = currentElement.parentNode;
  }

  return !!currentElement;
}

var onClick = Symbol('onClick');
var onKeydown = Symbol('onKeydown');
var addEventDelegation = Symbol('addEventDelegation');
var addEventListeners = Symbol('addEventListeners');
var removeEventListeners = Symbol('removeEventListeners');
var addAttributes = Symbol('addAttributes');
var removeAttributes = Symbol('removeAttributes');
var setAttributes = Symbol('setAttributes');
var setFocusableElements = Symbol('setFocusableElements');
var setFocus = Symbol('setFocus');
var restoreFocus = Symbol('restoreFocus');
var switchFocus = Symbol('switchFocus');
var maintainFocus = Symbol('maintainFocus');
var addObserver = Symbol('addObserver');
var removeObserver = Symbol('removeObserver');
var customConfig = config; // Update the global configuration if needed

function setDefaults() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$documentSelector = _ref.documentSelector,
      documentSelector = _ref$documentSelector === void 0 ? customConfig.documentSelector : _ref$documentSelector,
      _ref$documentDisabled = _ref.documentDisabledClass,
      documentDisabledClass = _ref$documentDisabled === void 0 ? customConfig.documentDisabledClass : _ref$documentDisabled,
      _ref$openingTriggerAc = _ref.openingTriggerActiveClass,
      openingTriggerActiveClass = _ref$openingTriggerAc === void 0 ? customConfig.openingTriggerActiveClass : _ref$openingTriggerAc,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? customConfig.delay : _ref$delay;

  customConfig = _objectSpread2(_objectSpread2({}, config), {
    documentSelector: documentSelector,
    documentDisabledClass: documentDisabledClass,
    openingTriggerActiveClass: openingTriggerActiveClass,
    delay: delay
  });
} // Export the default Dialog() class

var Dialog = /*#__PURE__*/function () {
  function Dialog(dialogSelector) {
    var _this = this;

    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$onOpen = _ref2.onOpen,
        onOpen = _ref2$onOpen === void 0 ? function () {} : _ref2$onOpen,
        _ref2$onClose = _ref2.onClose,
        onClose = _ref2$onClose === void 0 ? function () {} : _ref2$onClose,
        openingSelector = _ref2.openingSelector,
        closingSelector = _ref2.closingSelector,
        backdropSelector = _ref2.backdropSelector,
        helperSelector = _ref2.helperSelector,
        labelledby = _ref2.labelledby,
        describedby = _ref2.describedby,
        _ref2$isModal = _ref2.isModal,
        isModal = _ref2$isModal === void 0 ? true : _ref2$isModal,
        _ref2$isTooltip = _ref2.isTooltip,
        isTooltip = _ref2$isTooltip === void 0 ? false : _ref2$isTooltip,
        _ref2$isOpen = _ref2.isOpen,
        isOpen = _ref2$isOpen === void 0 ? false : _ref2$isOpen,
        _ref2$isCreated = _ref2.isCreated,
        isCreated = _ref2$isCreated === void 0 ? true : _ref2$isCreated,
        _ref2$disableScroll = _ref2.disableScroll,
        disableScroll = _ref2$disableScroll === void 0 ? true : _ref2$disableScroll,
        _ref2$enableAutoFocus = _ref2.enableAutoFocus,
        enableAutoFocus = _ref2$enableAutoFocus === void 0 ? true : _ref2$enableAutoFocus,
        _ref2$openingTriggerA = _ref2.openingTriggerActiveClass,
        openingTriggerActiveClass = _ref2$openingTriggerA === void 0 ? customConfig.openingTriggerActiveClass : _ref2$openingTriggerA,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === void 0 ? customConfig.delay : _ref2$delay;

    _classCallCheck(this, Dialog);

    // Check if the dialog exists, if not, set `isInitialized` to false
    if (!document.querySelector(dialogSelector)) {
      this.isInitialized = false;
      return;
    } // Save the initial configuration


    this.config = {
      dialogSelector: dialogSelector,
      onOpen: onOpen,
      onClose: onClose,
      openingSelector: openingSelector,
      closingSelector: closingSelector,
      backdropSelector: backdropSelector,
      helperSelector: helperSelector,
      labelledby: labelledby,
      describedby: describedby,
      isModal: isModal,
      isTooltip: isTooltip,
      isCreated: isCreated,
      isOpen: isOpen,
      disableScroll: disableScroll,
      enableAutoFocus: enableAutoFocus,
      documentSelector: customConfig.documentSelector,
      documentDisabledClass: customConfig.documentDisabledClass,
      openingTriggerActiveClass: openingTriggerActiveClass,
      delay: delay
    };
    this.dialog = document.querySelector(dialogSelector);
    this.dialogArea = "".concat(dialogSelector, ", ").concat(openingSelector);
    this.openingTriggers = document.querySelectorAll(openingSelector);
    this.backdropTrigger = document.querySelector(backdropSelector);
    this.helpers = document.querySelectorAll(helperSelector);
    this.document = document.querySelector(this.config.documentSelector) || document.querySelector('html');
    this.documentIsAlreadyDisabled = false;
    this.focusableElements = [];
    this.firstFocusableElement = null;
    this.lastFocusableElement = null;
    this.openingTrigger = null;
    this.closingTrigger = null;
    this.isCreated = false;
    this.isOpen = false;
    this.close = this.close.bind(this);
    this.toggle = this.toggle.bind(this);
    this[onClick] = this[onClick].bind(this);
    this[onKeydown] = this[onKeydown].bind(this);
    this[addEventDelegation] = this[addEventDelegation].bind(this);
    this[switchFocus] = this[switchFocus].bind(this); // Add mutation observer to update focusable elements

    this.observer = new MutationObserver(function (mutations) {
      return mutations.forEach(function () {
        return _this[setFocusableElements]();
      });
    }); // initialize the dialog

    this.isInitialized = true; // Create the dialog

    if (isCreated) this.create();
  }

  _createClass(Dialog, [{
    key: onClick,
    value: function value(event) {
      if (this.config.isTooltip && !event.target.closest(this.dialogArea)) {
        this.close(event);
      }

      if (event.target === this.backdropTrigger) this.close(event);
    }
  }, {
    key: onKeydown,
    value: function value(event) {
      switch (event.key) {
        case keyCodes.escape:
          event.stopPropagation();
          this.close(event);
          break;

        case keyCodes.f6:
          if (!this.config.isModal) !this.config.isTooltip ? this[restoreFocus]() : this.close(event);
          break;

        case keyCodes.tab:
          this[maintainFocus](event);
          break;
      }
    }
  }, {
    key: addEventDelegation,
    value: function value(event) {
      var _this2 = this;

      document.querySelectorAll(this.config.openingSelector).forEach(function (openingTrigger) {
        if (closest(event.target, openingTrigger)) {
          _this2.openingTrigger = openingTrigger;

          _this2.toggle(event);
        }
      });
      document.querySelectorAll(this.config.closingSelector).forEach(function (closingTrigger) {
        if (closest(event.target, closingTrigger)) {
          _this2.closingTrigger = closingTrigger;

          _this2.close();
        }
      });
    }
  }, {
    key: addEventListeners,
    value: function value() {
      document.addEventListener('click', this[onClick], {
        capture: true
      });
      this.dialog.addEventListener('keydown', this[onKeydown]);
    }
  }, {
    key: removeEventListeners,
    value: function value() {
      document.removeEventListener('click', this[onClick], {
        capture: true
      });
      this.dialog.removeEventListener('keydown', this[onKeydown]);
      if (this.openingTrigger) this.openingTrigger.removeEventListener('keydown', this[switchFocus]);
    }
  }, {
    key: addAttributes,
    value: function value() {
      this.dialog.setAttribute('role', 'dialog');
      this.dialog.setAttribute('tabindex', -1);
      this.dialog.setAttribute('aria-hidden', true);
      if (this.config.labelledby) this.dialog.setAttribute('aria-labelledby', this.config.labelledby);
      if (this.config.describedby) this.dialog.setAttribute('aria-describedby', this.config.describedby);
      if (this.config.isModal) this.dialog.setAttribute('aria-modal', true);
      this.openingTriggers.forEach(function (openingTrigger) {
        return openingTrigger.setAttribute('aria-haspopup', 'dialog');
      });
    }
  }, {
    key: removeAttributes,
    value: function value() {
      var _this3 = this;

      this.dialog.removeAttribute('role');
      this.dialog.removeAttribute('tabindex');
      this.dialog.removeAttribute('aria-hidden');
      this.dialog.removeAttribute('aria-labelledby');
      this.dialog.removeAttribute('aria-describedby');
      this.dialog.removeAttribute('aria-modal');

      if (this.config.disableScroll && this.isOpen && !this.documentIsAlreadyDisabled) {
        this.document.classList.remove(this.config.documentDisabledClass);
      }

      this.openingTriggers.forEach(function (openingTrigger) {
        return openingTrigger.removeAttribute('aria-haspopup');
      });
      if (this.openingTrigger) this.openingTrigger.classList.remove(this.config.openingTriggerActiveClass);
      this.helpers.forEach(function (helper) {
        return helper.classList.remove(_this3.config.openingTriggerActiveClass);
      });
    }
  }, {
    key: setAttributes,
    value: function value() {
      var _this4 = this;

      this.dialog.setAttribute('aria-hidden', !this.isOpen);

      if (this.config.disableScroll && !this.documentIsAlreadyDisabled) {
        if (this.isOpen) {
          this.document.classList.add(this.config.documentDisabledClass);
        } else {
          this.document.classList.remove(this.config.documentDisabledClass);
        }
      }

      if (this.openingTrigger) {
        if (this.isOpen) {
          this.openingTrigger.classList.add(this.config.openingTriggerActiveClass);
        } else {
          this.openingTrigger.classList.remove(this.config.openingTriggerActiveClass);
        }
      }

      this.helpers.forEach(function (helper) {
        if (_this4.isOpen) {
          helper.classList.add(_this4.config.openingTriggerActiveClass);
        } else {
          helper.classList.remove(_this4.config.openingTriggerActiveClass);
        }
      });
    }
  }, {
    key: setFocusableElements,
    value: function value() {
      var visibleFocusableElements = getVisibleElements(this.dialog.querySelectorAll(focusableElements));
      var filteredFocusableElements = getNoNestedElements(this.dialog, '[role="dialog"]', visibleFocusableElements);
      this.focusableElements = filteredFocusableElements.length > 0 ? filteredFocusableElements : [this.dialog];

      var _this$focusableElemen = _slicedToArray(this.focusableElements, 1);

      this.firstFocusableElement = _this$focusableElemen[0];
      this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];
    }
  }, {
    key: setFocus,
    value: function value() {
      var _this5 = this;

      if (this.config.enableAutoFocus) window.setTimeout(function () {
        return _this5.firstFocusableElement.focus();
      }, this.config.delay);
    }
  }, {
    key: restoreFocus,
    value: function value() {
      var _this6 = this;

      if (this.config.enableAutoFocus) window.setTimeout(function () {
        return _this6.openingTrigger.focus();
      }, this.config.delay); // Switch focus between the current opening trigger and the non-modal dialog

      if (this.isOpen) this.openingTrigger.addEventListener('keydown', this[switchFocus]);
    }
  }, {
    key: switchFocus,
    value: function value(event) {
      if (event.key === keyCodes.f6) {
        this.openingTrigger.removeEventListener('keydown', this[switchFocus]);
        this[setFocus]();
      }
    }
  }, {
    key: maintainFocus,
    value: function value(event) {
      if (event.shiftKey && event.target === this.firstFocusableElement) {
        event.preventDefault();
        this.lastFocusableElement.focus();
      }

      if (!event.shiftKey && event.target === this.lastFocusableElement) {
        event.preventDefault();
        this.firstFocusableElement.focus();
      }
    }
  }, {
    key: addObserver,
    value: function value() {
      this.observer.observe(this.dialog, {
        childList: true,
        attributes: true,
        subtree: true
      });
    }
  }, {
    key: removeObserver,
    value: function value() {
      this.observer.disconnect();
    }
  }, {
    key: "open",
    value: function open() {
      if (!this.isInitialized || !this.isCreated || this.isOpen) return;
      this.isOpen = true;
      this.documentIsAlreadyDisabled = this.document.classList.contains(this.config.documentDisabledClass);
      this[setAttributes]();
      this[addEventListeners]();
      this[setFocus]();
      this.config.onOpen(this.dialog, this.openingTrigger);
    }
  }, {
    key: "close",
    value: function close(event) {
      if (!this.isInitialized || !this.isCreated || !this.isOpen) return;
      this.isOpen = false;
      if (event) event.preventDefault();
      this[setAttributes]();
      this[removeEventListeners](); // Restore focus except for tooltip click events

      if (this.openingTrigger && (!this.config.isTooltip || this.config.isTooltip && event && event.type !== 'click')) {
        this[restoreFocus]();
      }

      this.config.onClose(this.dialog, this.closingTrigger);
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (!this.isInitialized || !this.isCreated) return;
      if (event) event.preventDefault();
      this.isOpen ? this.close() : this.open();
    }
  }, {
    key: "create",
    value: function create() {
      if (!this.isInitialized || this.isCreated) return;
      this.isCreated = true;
      this[addAttributes]();
      this[setFocusableElements]();
      this[addObserver]();
      if (this.config.isOpen) this.open();
      document.addEventListener('click', this[addEventDelegation], {
        capture: true
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.isInitialized || !this.isCreated) return;
      this.close();
      this.isCreated = false;
      this[removeAttributes]();
      this[removeEventListeners]();
      this[removeObserver]();
      document.removeEventListener('click', this[addEventDelegation], {
        capture: true
      });
    }
  }]);

  return Dialog;
}();

exports.default = Dialog;
exports.setDefaults = setDefaults;
